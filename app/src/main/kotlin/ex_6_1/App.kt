/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package ex_6_1

import org.checkerframework.checker.nullness.Opt
import java.lang.RuntimeException

sealed class Option<out A> {
    abstract fun isEmpty(): Boolean

    fun <B> map(f: (A) -> B): Option<B> =
        when (this) {
            is None -> None
            is Some -> Some(f(value))
    }

    fun <B> flatMap(f: (A)-> Option<B>): Option<B> =
        map(f).getOrElse(None)

    fun getOrElse(default: @UnsafeVariance A): A = when (this) {
        is None -> default
        is Some -> value
    }

    fun getOrElse(default:()-> @UnsafeVariance A): A =
       when (this){
            is None -> default()
            is Some -> value
       }

    fun orElse(default: () -> Option<@UnsafeVariance A>): Option<A> =
        map {_ -> this }.getOrElse(default)

    fun filter( p: (A)  -> Boolean): Option<A> =
    flatMap{x-> if(p(x)) this else None}

    internal object None: Option<Nothing>() {
        override fun isEmpty()=true
        override fun toString(): String = "None"
        override fun equals(other:Any?): Boolean = other ===None
        override fun hashCode(): Int = 0
    }
    internal data class Some<out A> (internal val value : A) : Option<A>() {
        override fun isEmpty()= false
    }
    companion object {
        operator fun <A> invoke (a:A?=null): Option<A> =
            when(a) {
                null -> None
                else -> Some(a)
            }
    }
}


fun max(list : List<Int>): Option<Int>  = Option.invoke(list.maxOrNull())
fun getDefaultInt(): Int = throw RuntimeException()
fun getDefaultList(): List<Int> = throw RuntimeException()
fun <B> getDefaultOption(): Option<B> =
    Option<B>()

val variance: (List<Double>) -> Option<Double> =
    {
        list->
        mean(list).flatMap {
            m->mean(list.map{x-> Math.pow((x-m),2.0)})
        }
    }


val mean : (List<Double>) -> Option<Double> =
    {list ->
        when{
            list.isEmpty()->Option()
            else-> Option(list.sum()/list.size)
             }
    }

fun <A, B> lift(f: (A) -> B): (Option<A>) -> Option<B> =
    { it.map(f) } //it type Automatically declared based on the expected Type

val upperOption: (Option<String>) -> Option<String> =
    lift(String::toUpperCase)


class App {
    val greeting: String
        get() {
            return "Hello World!"
        }
    public fun max() : Int? = null
}

fun <A> TestAutomaticalyDeclared(a: A): (Option<A>) -> Option<A> = {it}





fun main() {
    println(App().greeting)
    val max1=max(listOf(3,5,7,2,1)).getOrElse(::getDefaultInt)
    println(max1)

//    val max2=max(listOf()).getOrElse(::getDefault)
//    println(max2)

    val optionTest=max(listOf(1))
    val resultMap=optionTest.map{ listOf(it,-it)}
    println(resultMap)

    val resultFlatmapSome=Option(7).flatMap{Option(it*3)}
    println(resultFlatmapSome)

   println("\n")
   println(optionTest.orElse { getDefaultOption() })

   println("\n")

   println(optionTest.filter {it>1})
   println(optionTest.filter {it==1})

   println("\n")
   val s1=Option("TestMyString")
   println(upperOption(s1))

   println("\n")
   val s="check chek check"
   val t= TestAutomaticalyDeclared(s)
    val z=Option("zzzzz")
    
   println(z)

}
